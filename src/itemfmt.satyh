@require: base/list-ext
@require: base/length
@require: base/color-ext
@require: gr

type labelwithemptybody =
  | LabelDisplay  % テキストが空でもかまわずラベルを描画する。
  | LabelInherit  % ラベルは描画せず、自身の子要素があればそこでラベルを一緒に描画してもらう。
  | LabelIgnore   % ラベルを描かず、継承もしない。

type itemconfig = (|
  % 基準となるインデントの量。
  % 本文の左端から indent-base だけ右にずらした線を基準線とよび、
  % ラベルの揃え方や本文のインデント量はこの基準線をもとに設定される。
  indent-base: length -> length;

  % ラベルの直後に来るテキストのインデントの量。
  % args:
  %   width (length): ラベルのインラインボックス列の横幅。
  indent-start: length -> length;

  % 現在のアイテムのインデックスを与えて、ラベルのインラインボックス列を返す。
  label: inline-boxes;

  % ラベルに対応するテキストが空のとき、ラベルの描画をどのように行うか。
  label-with-empty-body: labelwithemptybody;

  % 箇条書きの段落の上に追加であける余白（paragraph-margin による余白はそのまま入る）。
  margin-top: length;

  % 箇条書きの段落の下に追加であける余白（paragraph-margin による余白はそのまま入る）。
  margin-bottom: length;

  % 中身の context を変換する関数。
  context-inner: (context -> context);
|)

module EnumitemFormat : sig

% builder
  val init : context -> int list -> itemconfig
  val default : itemconfig

  val new : (context -> int list -> inline-boxes) -> context -> int list -> itemconfig
  val new-unordered : (context -> inline-boxes) -> context -> int list -> itemconfig
  val new-unordered-with-depth : (context -> int -> inline-boxes) -> context -> int list -> itemconfig
  val new-ordered : (context -> int -> inline-boxes) -> context -> int list -> itemconfig
  val new-description : length?-> (inline-text -> inline-text) -> inline-text -> context -> int list -> itemconfig

  % val change-by-depth : (context -> int list -> itemconfig) list -> context -> int list -> itemconfig

end = struct

  let id x = x

  let default = (|
    indent-base = (fun _ -> 0pt);
    indent-start = (fun _ -> 0pt);
    label = inline-nil;
    label-with-empty-body = LabelIgnore;
    margin-top = 0pt;
    margin-bottom = 0pt;
    context-inner = id;
  |)

  let init _ _ = default

  let new-unordered labelf  ctx _ =
    (|
      indent-base = id;
      indent-start = id;
      label = labelf ctx;
      label-with-empty-body = LabelIgnore;
      margin-top = 0pt;
      margin-bottom = 0pt;
      context-inner = id;
    |)

  let new-unordered-with-depth labelf  ctx idxlst =
    (|
      indent-base = id;
      indent-start = id;
      label = labelf ctx (List.length idxlst);
      label-with-empty-body = LabelIgnore;
      margin-top = 0pt;
      margin-bottom = 0pt;
      context-inner = id;
    |)

  let new-ordered labelf  ctx idxlst =
    let label = match idxlst with
      | [] -> labelf ctx 0
      | idx :: _ -> labelf ctx idx
    in
    (|
      indent-base = id;
      indent-start = id;
      label = label;
      label-with-empty-body = LabelInherit;
      margin-top = 0pt;
      margin-bottom = 0pt;
      context-inner = id;
    |)

  let new labelf  ctx idxlst =
    (|
      indent-base = id;
      indent-start = id;
      label = labelf ctx idxlst;
      label-with-empty-body = LabelIgnore;
      margin-top = 0pt;
      margin-bottom = 0pt;
      context-inner = id;
    |)

  let new-description ?:min-indent itf  it ctx idxlst =
    let min-indent = min-indent |> Option.from (get-font-size ctx *' 2.0) in
    let indent wid = 
      Length.max min-indent (wid +' get-font-size ctx *' 1.0)
    in
    (|
      indent-base = (fun _ -> min-indent);
      indent-start = indent;
      label = read-inline ctx (itf it);
      label-with-empty-body = LabelDisplay;
      margin-top = 0pt;
      margin-bottom = 0pt;
      context-inner = id;
    |)

% setter

end
