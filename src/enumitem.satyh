@require: base/option-ext
@require: base/length
@require: base/tuple
@import: ./param
@import: ./itemfmt

module Enumitem : sig

  % val spaced-itemfmt: length -> context -> itemfmt
  % val nofmt: length -> context -> itemfmt

  direct +item : [itemfmt?; inline-text; itemfmt?; block-text]  block-cmd
  direct +itemize : [itemfmt; block-text]  block-cmd
  direct \sublist: [itemfmt; itemize] inline-cmd

end = struct

  let-mutable counter-stack <- []
  let-mutable label-stack <- []
  let display-counter () =
    let-rec aux s lst = match lst with
      | [] -> ` `
      | x :: rest -> ((arabic x) ^ #` `# ^ (aux s rest))
    in
    `counter:` ^ (aux ` ` !counter-stack) |> display-message

  let push-counter () = counter-stack <- 0 :: !counter-stack
  let push-label label indent = label-stack <- (label, indent) :: !label-stack

  let inc-counter n = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> (x + n) :: rest
  )
  let pop-counter () = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> rest
  )

  let get-all-label () =
    let label-with-margin (label, indent) =
      let (_, h, d) = get-natural-metrics label in
      inline-graphics indent h d (fun pt -> [ draw-text pt label ])
    in
    !label-stack |> List.reverse |> List.map label-with-margin |> List.fold-left (++) inline-nil
  let get-all-indent () =
    !label-stack |> List.map Pair.snd |> List.fold-left (+') 0pt
  let pop-labels () =
    let label = get-all-label () in
    let indent = get-all-indent () in
    let () = label-stack <- [] in
    (label, indent)

  let set-counter n = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> n :: rest
  )
  let-inline \set-counter n = let () = set-counter n in {}

  let sublist-stack = EnumitemParam.make '<>

  let empty-deco _ _ _ _ = []
  let empty-decoset = (empty-deco, empty-deco, empty-deco, empty-deco)

  let no-pad = (0pt, 0pt, 0pt, 0pt)

  let current-itemfmt = EnumitemParam.make EnumitemFormat.init

  let-block ctx +item ?:itemfmt it ?:itemfmt-children inner =
    let itemfmt = itemfmt |> Option.from (EnumitemParam.get current-itemfmt) in

    let () = inc-counter 1 in
    let () = display-counter () in

    let ib-label = itemfmt#label ctx !counter-stack in
    let (wid-label, ht-label, dp-label) = get-natural-metrics ib-label in
    let indent-base = itemfmt#indent-base ctx wid-label in
    let () = push-label ib-label indent-base in

    let bbf ctx =

      let () = sublist-stack |> EnumitemParam.discard in
      let ib = read-inline ctx it in
      let bt-inner-additional = sublist-stack |> EnumitemParam.get in

      let bb-body =
        let (w, h, d) = get-natural-metrics ib in
        if Length.(w == 0pt && h == 0pt && d == 0pt) && (not itemfmt#display-label-with-empty-body) then
          block-nil
        else
          let indent-start = itemfmt#indent-start ctx wid-label in
          let (ib-label-all, indent-all) = pop-labels () in
          let ib-label-with-skip =
            % inline-graphics 0pt ht-label dp-label (fun (x, y) -> [
            %   draw-text (x -' indent-base, y) ib-label
            % ])
            inline-skip (0pt -' indent-all) ++ ib-label-all
          in
          line-break true true ctx (
              ib-label-with-skip ++ inline-skip (indent-start -' indent-base) ++ ib ++ inline-fil
          )
      in

      let bb-inner =
        let ctx = ctx |> itemfmt#context-inner in

        % 事前に起こしておく副作用
        let () = push-counter () in
        let current-itemfmt-old = EnumitemParam.get current-itemfmt in
        let () = match itemfmt-children with
          | Some(fmt) -> current-itemfmt |> EnumitemParam.set fmt
          | None -> ()
        in

        % read-block
        let bb-inner = read-block ctx '<#bt-inner-additional;#inner;> in

        % 起こした副作用の後片付け
        let () = pop-counter () in
        let () = current-itemfmt |> EnumitemParam.set current-itemfmt-old in

        if Length.(get-natural-length bb-inner == 0pt) then
          block-nil
        else
          block-frame-breakable ctx (0pt, 0pt, itemfmt#margin-top ctx, itemfmt#margin-bottom ctx)
            empty-decoset (fun ctx -> bb-inner)
      in
      bb-body +++ bb-inner
    in
    block-frame-breakable ctx (indent-base, 0pt, 0pt, 0pt) empty-decoset bbf

  let-block +itemize itemfmt bt =
    '< +item?:(EnumitemFormat.init)({})?:(itemfmt)(bt); >

  let-rec convert-item-to-bt itemfmt (Item(it, children)) =
    let bt-children =
      children |> List.map (convert-item-to-bt itemfmt)
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    '< +item?:(itemfmt)(it)(bt-children); >

  let-inline ctx \sublist itemfmt (Item(_, children)) =
    let bt-children =
      children |> List.map (convert-item-to-bt itemfmt)
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    let () = sublist-stack |> EnumitemParam.set bt-children in
    inline-nil

end

module EnumitemFormatUtil : sig

% text mapping function
  val to-arabic: int -> inline-text
  val to-roman : int -> inline-text
  val to-Roman : int -> inline-text
  val to-alph  : int -> inline-text
  val to-Alph  : int -> inline-text

% index decolation function (ordered)
  val raw     : (int -> inline-text) -> context -> int -> inline-boxes
  val dot     : (int -> inline-text) -> context -> int -> inline-boxes
  val paren   : (int -> inline-text) -> context -> int -> inline-boxes
  val bracket : (int -> inline-text) -> context -> int -> inline-boxes

% index decolation function (unordered)
  val shape-bullet       : context -> inline-boxes
  val shape-white-bullet : context -> inline-boxes

% adjuster
  val align-right: length -> inline-boxes -> inline-boxes

end = struct

% text mapping

  let num-to-roman-char capital num =
    let unic-point = match num with
      |  1 -> 0x0049  % `I`
      |  5 -> 0x0056  % `V`
      | 10 -> 0x0058  % `X`
      |  _ -> 0x003F  % `?`
    in
    if capital then unic-point else unic-point + 0x20

  let roman-seq num = match num with
    |  1 -> [ 1;                 ] % i
    |  2 -> [ 1;  1;             ] % ii
    |  3 -> [ 1;  1;  1;         ] % iii
    |  4 -> [ 1;  5;             ] % iv
    |  5 -> [ 5;                 ] % v
    |  6 -> [ 5;  1;             ] % vi
    |  7 -> [ 5;  1;  1;         ] % vii
    |  8 -> [ 5;  1;  1;  1;     ] % viii
    |  9 -> [ 1; 10;             ] % ix
    | 10 -> [10;                 ] % x
    | 11 -> [10;  1;             ] % xi
    | 12 -> [10;  1;  1;         ] % xii
    | 13 -> [10;  1;  1;  1;     ] % xiii
    | 14 -> [10;  1;  5;         ] % xiv
    | 15 -> [10;  5;             ] % xv
    | 16 -> [10;  5;  1;         ] % xvi
    | 17 -> [10;  5;  1;  1;     ] % xvii
    | 18 -> [10;  5;  1;  1;  1; ] % xviii
    | 19 -> [10;  1; 10;         ] % xix
    | 20 -> [10; 10;             ] % xx
    | 21 -> [10; 10;  1;         ] % xxi
    | 22 -> [10; 10;  1;  1;     ] % xxii
    | 23 -> [10; 10;  1;  1;  1; ] % xxiii
    | 24 -> [10; 10;  1;  5;     ] % xxiv
    | 25 -> [10; 10;  5;         ] % xxv
    |  _ -> [ 0;  0;             ] % ??

  let to-arabic num = embed-string (arabic num)

  let to-roman num =
    embed-string
      (string-unexplode
        (List.map (fun i -> num-to-roman-char false i) (roman-seq num)))
  let to-Roman num =
    embed-string
      (string-unexplode
        (List.map (fun i -> num-to-roman-char true i) (roman-seq num)))

  let to-alph num = embed-string (string-unexplode [num + 0x0060;])
  let to-Alph num = embed-string (string-unexplode [num + 0x0040;])

% index decolation function (ordered)

  let raw num-format ctx idx =
    let it-num = num-format idx in
    let ib-label = read-inline ctx {#it-num;\ } in
    let (wid-label, _, _) = get-natural-metrics ib-label in
    ib-label

  let dot num-format ctx idx =
    let it-num = num-format idx in
    let ib-label = read-inline ctx {#it-num;.\ } in
    let (wid-label, _, _) = get-natural-metrics ib-label in
    ib-label

  let paren num-format ctx idx =
    let it-num = num-format idx in
    let ib-label = read-inline ctx {(#it-num;)\ } in
    let (wid-label, _, _) = get-natural-metrics ib-label in
    ib-label

  let bracket num-format ctx idx =
    let it-num = num-format idx in
    let ib-label = read-inline ctx {[#it-num;]\ } in
    let (wid-label, _, _) = get-natural-metrics ib-label in
    ib-label

% index decolation function (unordered)

  let shape-bullet ctx =
    let font-size = get-font-size ctx in
    let interval = font-size *' 0.3 in
    let circ ctx (x, y) =
      let cx = x +' font-size -' (font-size *' 0.3) -' interval in
      let cy = y +' font-size *' 0.3 in
      let r = font-size *' 0.15 in
      Gr.circle (cx, cy) r
    in
    inline-graphics font-size (font-size *' 0.5) 0pt
      (fun (x, y) -> [fill Color.black (circ ctx (x, y))])

  let shape-white-bullet ctx =
    let font-size = get-font-size ctx in
    let interval = font-size *' 0.3 in
    let circ ctx (x, y) =
      let cx = x +' font-size -' (font-size *' 0.3) -' interval in
      let cy = y +' font-size *' 0.3 in
      let r = font-size *' 0.12 in
      Gr.circle (cx, cy) r
    in
    inline-graphics font-size (font-size *' 0.5) 0pt
      (fun (x, y) -> [stroke 0.8pt Color.black (circ ctx (x, y))])

% adjuster
  let align-right wid ib =
    let (wid-ib, ht, dp) = get-natural-metrics ib in
    inline-graphics wid ht dp (fun (x, y) -> [draw-text (x +' wid -' wid-ib, y) ib])
end


module EnumitemFormatAlias : sig

  val nofmt : itemfmt

  val raw-arabic: itemfmt
  val dot-arabic-rec: itemfmt

% listing
  val bullet: itemfmt
  val white-bullet: itemfmt

  val description: inline-text -> itemfmt
  val description-newline: inline-text -> itemfmt

  direct +listing: [itemfmt?; length?; itemize] block-cmd

  val +ditem: [(inline-text -> itemfmt)?; inline-text; inline-text] block-cmd
  val +ditemln: [(inline-text -> itemfmt)?; inline-text; block-text] block-cmd

end = struct

  open EnumitemFormat

  let nofmt = init

% formats
  let raw-arabic =
    let labelf ctx idx = EnumitemFormatUtil.(
      raw to-arabic ctx idx |> align-right (get-font-size ctx *' 2.0)
    )
    in
    init
      |> set-label-by-index labelf
      |> set-indent-base (fun ctx _ -> get-font-size ctx *' 2.)
      |> set-indent-start (fun ctx _ -> get-font-size ctx *' 2.)

  let bullet =
    let labelf ctx = EnumitemFormatUtil.(
      inline-skip (get-font-size ctx *' 0.5) ++ shape-bullet ctx
    )
    in
    init
      |> set-label-by-context labelf
      |> set-indent-base (fun ctx _ -> get-font-size ctx *' 1.5)
      |> set-indent-start (fun ctx _ -> get-font-size ctx *' 1.5)

  let white-bullet =
    let labelf ctx = EnumitemFormatUtil.(
      inline-skip (get-font-size ctx *' 0.5) ++ shape-white-bullet ctx
    )
    in
    init
      |> set-label-by-context labelf
      |> set-indent-base (fun ctx _ -> get-font-size ctx *' 1.5)
      |> set-indent-start (fun ctx _ -> get-font-size ctx *' 1.5)

  let dot-arabic-rec =
    let labelf ctx idxlst =
      idxlst |> List.map arabic |> List.map embed-string
             |> List.fold-left (fun it1 it2 -> {#it2;.#it1;}) {\ }
             |> read-inline ctx
    in
    init
      |> set-label-by-nested-index labelf
      |> set-indent-base (fun ctx _ -> get-font-size ctx *' 2.)
      |> set-indent-start (fun ctx _ -> get-font-size ctx *' 2.)
      % |> set-label-align-right (fun ctx -> get-font-size ctx *' 2.)

% command
  let-rec convert-item-to-bt (Item(it, children)) =
    let bt-children =
      children |> List.map convert-item-to-bt
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    '< +item(it)(bt-children); >

  let listing-default-label =
    let labelf ctx depth =
      if depth mod 2 == 1 then bullet#label ctx [] else white-bullet#label ctx []
    in
    init |> set-label-by-depth labelf
         |> set-indent-base (fun ctx _ -> get-font-size ctx *' 1.5)
         |> set-indent-start (fun ctx _ -> get-font-size ctx *' 1.5)
         % |> set-label-align-right (fun ctx -> get-font-size ctx *' 1.5)

  let-block ctx +listing ?:itemfmt ?:margin (Item(_, children)) =
    let itemfmt = itemfmt |> Option.from listing-default-label in
    let margin = margin |> Option.from (get-font-size ctx *' 0.25) in
    let bt-children =
      children |> List.map convert-item-to-bt
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    read-block ctx '<
      +itemize(itemfmt)(bt-children);
    >

% description
  let description it =
    let labelf ctx = read-inline ctx it in
    init
      |> set-label-by-context labelf
      % |> set-label-align-left (fun ctx -> get-font-size ctx *' 1.) (fun ctx -> get-font-size ctx *' 2.)

  let description-newline it =
    let labelf ctx = read-inline ctx it in
    init
      |> set-label-by-context labelf
      % |> set-label-align-left (fun ctx -> get-font-size ctx *' 1.) (fun ctx -> get-font-size ctx *' 2.)
      |> set-display-label-flag true


  let-block ctx +ditem ?:itemfmtf dt it-dd =
    let itemfmtf = itemfmtf |> Option.from description in
    read-block ctx '<
      +item?:(itemfmtf dt)(it-dd)<>
    >

  let-block ctx +ditemln ?:itemfmtf dt bt-dd =
    let itemfmtf = itemfmtf |> Option.from description-newline in
    read-block ctx '<
      +item?:(itemfmtf dt)({})(bt-dd);
    >

end
