@require: base/option-ext
@require: base/length
@import: ./param
@import: ./itemfmt

module Enumitem : sig

  % val spaced-itemfmt: length -> context -> itemfmt
  % val nofmt: length -> context -> itemfmt

  direct +item : [itemfmt?; inline-text; itemfmt?; block-text]  block-cmd
  direct +itemize : [itemfmt; block-text]  block-cmd
  direct +listing: [itemfmt?; length?; itemize] block-cmd
  direct \sublist: [itemfmt; itemize] inline-cmd

end = struct

  let-mutable counter-stack <- []
  let display-counter () =
    let-rec aux s lst = match lst with
      | [] -> ` `
      | x :: rest -> ((arabic x) ^ #` `# ^ (aux s rest))
    in
    `counter:` ^ (aux ` ` !counter-stack) |> display-message

  let push-counter () =
    % match !counter-stack with
    % | 1 :: rest -> false
    % | _ -> let () = counter-stack <- 1 :: !counter-stack in true
    counter-stack <- 0 :: !counter-stack

  let inc-counter n = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> (x + n) :: rest
  )
  let pop-counter () = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> rest
  )
  let set-counter n = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> n :: rest
  )
  let-inline \set-counter n = let () = set-counter n in {}

  let sublist-stack = EnumitemParam.make '<>

  let empty-deco _ _ _ _ = []
  let empty-decoset = (empty-deco, empty-deco, empty-deco, empty-deco)

  let no-pad = (0pt, 0pt, 0pt, 0pt)

  let current-itemfmt = EnumitemParam.make EnumitemFormat.init

  let-block ctx +item ?:itemfmt it ?:itemfmt-children inner =
    let itemfmt = itemfmt |> Option.from (EnumitemParam.get current-itemfmt) in

    let () = inc-counter 1 in
    let () = display-counter () in

    let ib-label = itemfmt#label ctx !counter-stack in
    let (wid-label, ht-label, dp-label) = get-natural-metrics ib-label in
    let indent-base = itemfmt#indent-base ctx in
    let indent-text = itemfmt#indent-text ctx wid-label in

    let bbf ctx =

      let () = sublist-stack |> EnumitemParam.discard in
      let ib = read-inline ctx it in
      let bt-inner-additional = sublist-stack |> EnumitemParam.get in

      let bb-body =
        let (w, h, d) = get-natural-metrics ib in
        if Length.(w == 0pt && h == 0pt && d == 0pt) && (not itemfmt#display-label-with-empty-body) then
          block-nil
        else
          let indent-start = itemfmt#indent-start ctx wid-label in
          let ib-gr-label =
            inline-graphics 0pt ht-label dp-label (fun (x, y) -> [
              draw-text (x -' indent-text -' wid-label *' itemfmt#label-align, y) ib-label
            ])
          in
          line-break true true ctx (
              ib-gr-label ++ inline-skip (indent-start -' indent-text) ++ ib ++ inline-fil
          )
      in
      let bb-inner =
        let ctx = ctx |> itemfmt#context-inner in

        % 事前に起こしておく副作用
        let () = push-counter () in
        let current-itemfmt-old = EnumitemParam.get current-itemfmt in
        let () = match itemfmt-children with
          | Some(fmt) -> current-itemfmt |> EnumitemParam.set fmt
          | None -> ()
        in

        % read-block
        let bb-inner = read-block ctx '<#bt-inner-additional;#inner;> in

        % 起こした副作用の後片付け
        let () = pop-counter () in
        let () = current-itemfmt |> EnumitemParam.set current-itemfmt-old in

        let h = get-natural-length bb-inner in
        if Length.(h == 0pt) then
          block-nil
        else
          block-frame-breakable ctx (0pt, 0pt, itemfmt#margin-top ctx, itemfmt#margin-bottom ctx)
            empty-decoset (fun ctx -> bb-inner)
      in
      bb-body +++ bb-inner
    in
    block-frame-breakable ctx (indent-base +' indent-text, 0pt, 0pt, 0pt) empty-decoset bbf

  let-block +itemize itemfmt bt =
    '< +item?:(EnumitemFormat.init)({})?:(itemfmt)(bt); >

  let-rec convert-item-to-bt itemfmt (Item(it, children)) =
    let bt-children =
      children |> List.map (convert-item-to-bt itemfmt)
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    '< +item?:(itemfmt)(it)(bt-children); >

  let-block ctx +listing ?:itemfmt ?:margin (Item(_, children)) =
    let itemfmt = itemfmt |> Option.from EnumitemFormat.init in
    let margin = margin |> Option.from (get-font-size ctx *' 0.25) in
    let bt-children =
      children |> List.map (convert-item-to-bt itemfmt)
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    read-block ctx '<
      +itemize(itemfmt)(bt-children);
    >

  let-inline ctx \sublist itemfmt (Item(_, children)) =
    let bt-children =
      children |> List.map (convert-item-to-bt itemfmt)
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    let () = sublist-stack |> EnumitemParam.set bt-children in
    inline-nil

end

module EnumitemFormatAlias : sig

  val nofmt : itemfmt

  val raw-arabic: itemfmt
  val dot-arabic-rec: itemfmt

  val description: inline-text -> itemfmt
  val description-newline: inline-text -> itemfmt

  val +ditem: [(inline-text -> itemfmt)?; inline-text; inline-text] block-cmd
  val +ditemln: [(inline-text -> itemfmt)?; inline-text; block-text] block-cmd

end = struct

  open EnumitemFormat

  let nofmt = init

% formats
  let raw-arabic = init
    |> set-label-by-index EnumitemFormatUtil.(raw to-arabic)
    |> set-label-align-right (fun ctx -> get-font-size ctx *' 2.)

  let dot-arabic-rec =
    let labelf ctx idxlst =
      idxlst |> List.map arabic |> List.map embed-string
             |> List.fold-left (fun it1 it2 -> {#it2;.#it1;}) {\ }
             |> read-inline ctx
    in
    init
      |> set-label-by-nested-index labelf
      |> set-label-align-right (fun ctx -> get-font-size ctx *' 2.)

% description
  let description it =
    let labelf ctx = read-inline ctx it in
    init
      |> set-label-by-context labelf
      |> set-label-align-left (fun ctx -> get-font-size ctx *' 1.) (fun ctx -> get-font-size ctx *' 2.)

  let description-newline it =
    let labelf ctx = read-inline ctx it in
    init
      |> set-label-by-context labelf
      |> set-label-align-left (fun ctx -> get-font-size ctx *' 1.) (fun ctx -> get-font-size ctx *' 2.)
      |> set-display-label-flag true

  let-block ctx +ditem ?:itemfmtf dt it-dd =
    let itemfmtf = itemfmtf |> Option.from description in
    read-block ctx '<
      +item?:(itemfmtf dt)(it-dd)<>
    >

  let-block ctx +ditemln ?:itemfmtf dt bt-dd =
    let itemfmtf = itemfmtf |> Option.from description-newline in
    read-block ctx '<
      +item?:(itemfmtf dt)({})(bt-dd);
    >

end
