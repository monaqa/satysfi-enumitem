%% enumitem.satyh

@require: base/option-ext
@require: base/length
@import: ./param

type itemfmt = (|
  % ラベルの長さを与えて、本文のインデント量を示す。
  indent: length -> length;
  % ラベルの長さを与えて、本文の最初の文字のインデント量を示す。
  indent-start: length -> length;
  % 現在のアイテムのインデックスを与えて、ラベルのインラインボックス列を返す。
  label: int list -> inline-boxes;
  margin-top: length;
  margin-bottom: length;
  context-inner: context -> context;
|)

module Enumitem : sig

  val spaced-itemfmt: length -> context -> itemfmt
  val nofmt: length -> context -> itemfmt

  direct +item : [(context -> itemfmt)?; inline-text; block-text]  block-cmd
  direct +listing: [(context -> itemfmt)?; length?; itemize] block-cmd
  direct \sublist: [context -> itemfmt; itemize] inline-cmd

end = struct

  let-mutable counter-stack <- []
  let display-counter () =
    let-rec aux s lst = match lst with
      | [] -> ` `
      | x :: rest -> ((arabic x) ^ #` `# ^ (aux s rest))
    in
    `counter:` ^ (aux ` ` !counter-stack) |> display-message

  let push-counter () =
    % match !counter-stack with
    % | 1 :: rest -> false
    % | _ -> let () = counter-stack <- 1 :: !counter-stack in true
    counter-stack <- 0 :: !counter-stack

  let inc-counter n = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> (x + n) :: rest
  )
  let pop-counter () = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> rest
  )
  let set-counter n = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> n :: rest
  )
  let-inline \set-counter n = let () = set-counter n in {}

  let sublist-stack = EnumitemParam.make '<>

  let empty-deco _ _ _ _ = []
  let empty-decoset = (empty-deco, empty-deco, empty-deco, empty-deco)

  let no-pad = (0pt, 0pt, 0pt, 0pt)

  let spaced-itemfmt vspace ctx =
    let label idxlst =
      idxlst |> List.map arabic |> List.map embed-string
             |> List.fold-left (fun it1 it2 -> {#it2;.#it1;}) {\ }
             |> read-inline ctx
    in
    (|
      indent = (fun x -> 20pt);
      indent-start = (fun x -> x +' 0pt);
      label = label;
      margin-top = vspace;
      margin-bottom = vspace;
      context-inner = (fun x -> x);
    |)

  let nofmt margin ctx =
    let label idxlst = inline-nil in
    (|
      indent = (fun _ -> 0pt);
      indent-start = (fun _ -> 0pt);
      label = label;
      margin-top = margin;
      margin-bottom = margin;
      context-inner = (fun x -> x);
    |)

  let-block ctx +item ?:itemfmtf it inner =
    let itemfmtf = itemfmtf |> Option.from (nofmt 0pt) in
    let itemfmt = itemfmtf ctx in

    let () = inc-counter 1 in
    let () = display-counter () in

    let ib-label = itemfmt#label !counter-stack in
    let (wid-label, _, _) = get-natural-metrics ib-label in
    let indent = itemfmt#indent wid-label in

    let bbf ctx =

      let () = sublist-stack |> EnumitemParam.discard in
      let ib = read-inline ctx it in
      let bt-inner-additional = sublist-stack |> EnumitemParam.get in

      let bb-body =
        let (w, h, d) = get-natural-metrics ib in
        if Length.(w == 0pt && h == 0pt && d == 0pt) then
          block-nil
        else
          let indent-start = itemfmt#indent-start wid-label in
          line-break true true ctx (
            inline-skip (0pt -' indent)
              ++ ib-label ++ inline-skip (indent-start -' wid-label)
                ++ ib ++ inline-fil
          )
      in
      let bb-inner =
        let ctx = ctx |> itemfmt#context-inner in
        let () = push-counter () in
        let bb-inner = read-block ctx '<#bt-inner-additional;#inner;> in
        let () = pop-counter () in
        let h = get-natural-length bb-inner in
        if Length.(h == 0pt) then
          block-nil
        else
          block-frame-breakable ctx (0pt, 0pt, itemfmt#margin-top, itemfmt#margin-bottom)
            empty-decoset (fun ctx -> bb-inner)
      in
      bb-body +++ bb-inner
    in
    block-frame-breakable ctx (indent, 0pt, 0pt, 0pt) empty-decoset bbf

  let-rec convert-item-to-bt itemfmtf (Item(it, children)) =
    let bt-children =
      children |> List.map (convert-item-to-bt itemfmtf)
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    '< +item?:(itemfmtf)(it)(bt-children); >

  let-block ctx +listing ?:itemfmtf ?:margin (Item(_, children)) =
    let itemfmtf = itemfmtf |> Option.from (spaced-itemfmt 0pt) in
    let margin = margin |> Option.from (get-font-size ctx *' 0.25) in
    let bt-children =
      children |> List.map (convert-item-to-bt itemfmtf)
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    read-block ctx '<
      +item?:(nofmt margin)({})(bt-children);
    >

  let-inline ctx \sublist itemfmtf (Item(_, children)) =
    let bt-children =
      children |> List.map (convert-item-to-bt itemfmtf)
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    let () = sublist-stack |> EnumitemParam.set bt-children in
    inline-nil

end
