%% enumitem.satyh

@require: base/option-ext
@require: base/length
@import: ./param
@import: ./itemfmt

% type itemfmt = (|
%   % ラベルの長さを与えて、本文のインデント量を示す。
%   indent: length -> length;
%   % ラベルの長さを与えて、本文の最初の文字のインデント量を示す。
%   indent-start: length -> length;
%   % 現在のアイテムのインデックスを与えて、ラベルのインラインボックス列を返す。
%   label: int list -> inline-boxes;
%   margin-top: length;
%   margin-bottom: length;
%   context-inner: context -> context;
% |)

module Enumitem : sig

  % val spaced-itemfmt: length -> context -> itemfmt
  % val nofmt: length -> context -> itemfmt

  direct +item : [itemfmt?; inline-text; block-text]  block-cmd
  direct +itemize : [itemfmt; block-text]  block-cmd
  direct +listing: [itemfmt?; length?; itemize] block-cmd
  direct \sublist: [itemfmt; itemize] inline-cmd

end = struct

  let-mutable counter-stack <- []
  let display-counter () =
    let-rec aux s lst = match lst with
      | [] -> ` `
      | x :: rest -> ((arabic x) ^ #` `# ^ (aux s rest))
    in
    `counter:` ^ (aux ` ` !counter-stack) |> display-message

  let push-counter () =
    % match !counter-stack with
    % | 1 :: rest -> false
    % | _ -> let () = counter-stack <- 1 :: !counter-stack in true
    counter-stack <- 0 :: !counter-stack

  let inc-counter n = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> (x + n) :: rest
  )
  let pop-counter () = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> rest
  )
  let set-counter n = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> n :: rest
  )
  let-inline \set-counter n = let () = set-counter n in {}

  let sublist-stack = EnumitemParam.make '<>

  let empty-deco _ _ _ _ = []
  let empty-decoset = (empty-deco, empty-deco, empty-deco, empty-deco)

  let no-pad = (0pt, 0pt, 0pt, 0pt)

  % let spaced-itemfmt vspace ctx =
  %   let label idxlst =
  %     idxlst |> List.map arabic |> List.map embed-string
  %            |> List.fold-left (fun it1 it2 -> {#it2;.#it1;}) {\ }
  %            |> read-inline ctx
  %   in
  %   (|
  %     indent = (fun x -> 20pt);
  %     indent-start = (fun x -> x +' 0pt);
  %     label = label;
  %     margin-top = vspace;
  %     margin-bottom = vspace;
  %     context-inner = (fun x -> x |> set-font-size (get-font-size x *' 1.2));
  %   |)
  % 
  % let nofmt margin ctx =
  %   let label idxlst = inline-nil in
  %   (|
  %     indent = (fun _ -> 0pt);
  %     indent-start = (fun _ -> 0pt);
  %     label = label;
  %     margin-top = margin;
  %     margin-bottom = margin;
  %     context-inner = (fun x -> x);
  %   |)

  let-block ctx +item ?:itemfmt it inner =
    let itemfmt = itemfmt |> Option.from EnumitemFormatAlias.nofmt in

    let () = inc-counter 1 in
    let () = display-counter () in

    let ib-label = itemfmt#label ctx !counter-stack in
    let (wid-label, ht-label, dp-label) = get-natural-metrics ib-label in
    let indent-base = itemfmt#indent-base ctx in
    let indent-text = indent-base +'itemfmt#indent-text ctx wid-label in

    let bbf ctx =

      let () = sublist-stack |> EnumitemParam.discard in
      let ib = read-inline ctx it in
      let bt-inner-additional = sublist-stack |> EnumitemParam.get in

      let bb-body =
        let (w, h, d) = get-natural-metrics ib in
        if Length.(w == 0pt && h == 0pt && d == 0pt) then
          block-nil
        else
          let indent-start = itemfmt#indent-start ctx wid-label in
          let ib-gr-label =
            inline-graphics 0pt ht-label dp-label (fun (x, y) -> [
              draw-text (x -' wid-label *' itemfmt#label-align, y) ib-label
            ])
          in
          line-break true true ctx (
              ib-gr-label ++ inline-skip indent-start ++ ib ++ inline-fil
          )
      in
      let bb-inner =
        let ctx = ctx |> itemfmt#context-inner in
        let () = push-counter () in
        let bb-inner = read-block ctx '<#bt-inner-additional;#inner;> in
        let () = pop-counter () in
        let h = get-natural-length bb-inner in
        if Length.(h == 0pt) then
          block-nil
        else
          block-frame-breakable ctx (0pt, 0pt, itemfmt#margin-top ctx, itemfmt#margin-bottom ctx)
            empty-decoset (fun ctx -> bb-inner)
      in
      bb-body +++ bb-inner
    in
    block-frame-breakable ctx (indent-text, 0pt, 0pt, 0pt) empty-decoset bbf

  let-block +itemize itemfmt bt =
    '< +item?:(EnumitemFormatAlias.nofmt)({})(bt); >

  let-rec convert-item-to-bt itemfmt (Item(it, children)) =
    let bt-children =
      children |> List.map (convert-item-to-bt itemfmt)
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    '< +item?:(itemfmt)(it)(bt-children); >

  let-block ctx +listing ?:itemfmt ?:margin (Item(_, children)) =
    let itemfmt = itemfmt |> Option.from EnumitemFormatAlias.nofmt in
    let margin = margin |> Option.from (get-font-size ctx *' 0.25) in
    let bt-children =
      children |> List.map (convert-item-to-bt itemfmt)
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    read-block ctx '<
      +item?:(EnumitemFormatAlias.nofmt)({})(bt-children);
    >

  let-inline ctx \sublist itemfmt (Item(_, children)) =
    let bt-children =
      children |> List.map (convert-item-to-bt itemfmt)
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    let () = sublist-stack |> EnumitemParam.set bt-children in
    inline-nil

end
