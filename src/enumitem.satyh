%% enumitem.satyh

@require: base/option-ext
@require: base/length
@import: ./param

type itemfmt = (|
  % ラベルの長さを与えて、本文のインデント量を示す。
  indent: length -> length;
  % ラベルの長さを与えて、本文の最初の文字のインデント量を示す。
  indent-start: length -> length;
  % 現在のアイテムのインデックスを与えて、ラベルのインラインボックス列を返す。
  label: int list -> inline-boxes;
  margin-top: length;
  margin-bottom: length;
|)

module Enumitem : sig

  val spaced-itemfmt: length -> context -> itemfmt
  val nofmt: context -> itemfmt

  direct +item : [(context -> itemfmt)?; inline-text; block-text]  block-cmd
  direct +listing: [context -> itemfmt; itemize] block-cmd

end = struct

  let-mutable counter-stack <- []
  let display-counter () =
    let-rec aux s lst = match lst with
      | [] -> ` `
      | x :: rest -> ((arabic x) ^ #` `# ^ (aux s rest))
    in
    `counter:` ^ (aux ` ` !counter-stack) |> display-message

  let push-counter () =
    % match !counter-stack with
    % | 1 :: rest -> false
    % | _ -> let () = counter-stack <- 1 :: !counter-stack in true
    counter-stack <- 0 :: !counter-stack

  let inc-counter n = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> (x + n) :: rest
  )
  let pop-counter () = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> rest
  )
  let set-counter n = counter-stack <- (
    match !counter-stack with
    | [] -> []
    | x :: rest -> n :: rest
  )
  let-inline \set-counter n = let () = set-counter n in {}

  let empty-deco _ _ _ _ = []
  let empty-decoset = (empty-deco, empty-deco, empty-deco, empty-deco)

  let no-pad = (0pt, 0pt, 0pt, 0pt)

  let spaced-itemfmt vspace ctx =
    let label idxlst =
      idxlst |> List.map arabic |> List.map embed-string
             |> List.fold-left (fun it1 it2 -> {#it2;.#it1;}) {\ }
             |> read-inline ctx
    in
    (|
      indent = (fun x -> 20pt);
      indent-start = (fun x -> x +' 0pt);
      label = label;
      margin-top = vspace;
      margin-bottom = vspace;
    |)

  let nofmt ctx =
    let label idxlst = inline-nil in
    (|
      indent = (fun _ -> 0pt);
      indent-start = (fun _ -> 0pt);
      label = label;
      margin-top = 3pt;
      margin-bottom = 3pt;
    |)

  let-block ctx +item ?:itemfmtf it inner =
    let itemfmtf = itemfmtf |> Option.from nofmt in
    let itemfmt = itemfmtf ctx in

    let () = inc-counter 1 in
    let () = display-counter () in

    let ib-label = itemfmt#label !counter-stack in
    let (wid-label, _, _) = get-natural-metrics ib-label in
    let indent = itemfmt#indent wid-label in

    let bbf ctx =
      let bb-body =
        let ib = read-inline ctx it in
        let (w, h, d) = get-natural-metrics ib in
        if Length.(w == 0pt && h == 0pt && d == 0pt) then
          block-nil
        else
          let indent-start = itemfmt#indent-start wid-label in
          line-break true true ctx (
            inline-skip (0pt -' indent)
              ++ ib-label ++ inline-skip (indent-start -' wid-label)
                ++ ib ++ inline-fil
          )
      in
      let bb-inner =
        let () = push-counter () in
        let bb-inner = read-block ctx inner in
        let () = pop-counter () in
        let h = get-natural-length bb-inner in
        if Length.(h == 0pt) then
          block-nil
        else
          block-frame-breakable ctx (0pt, 0pt, itemfmt#margin-top, itemfmt#margin-bottom)
            empty-decoset (fun ctx -> bb-inner)
      in
      bb-body +++ bb-inner
    in
    block-frame-breakable ctx (indent, 0pt, 0pt, 0pt) empty-decoset bbf

  let-rec convert-item-to-bt itemfmtf (Item(it, children)) =
    let bt-children =
      children |> List.map (convert-item-to-bt itemfmtf)
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    '<
      +item?:(itemfmtf)(it)(bt-children);
    >

  let-block ctx +listing itemfmtf (Item(_, children)) =
    let bt-children =
      children |> List.map (convert-item-to-bt itemfmtf)
               |> List.fold-left (fun bt1 bt2 -> '<#bt1;#bt2;>) '<>
    in
    read-block ctx '<
      +item?:(nofmt)({})(bt-children);
    >

end


% type itemstyle = int list -> context -> (|
%   label: inline-boxes;
%   left-indent: length;
%   first-line-left-indent: length;
%   right-indent: length;
%   inner-context: context -> context;
%   increment: int;
% |)

% module Enumitem: sig
% 
%   val default-style : itemstyle
%   val alph : itemstyle
%   val no-label : itemstyle
% 
%   direct \set-counter : [int] inline-cmd
% 
%   direct +itemize : [itemstyle; inline-text] block-cmd
% 
%   direct +listing : [itemstyle?; itemize] block-cmd
%   direct \listing : [itemstyle?; itemize] inline-cmd
%   direct \sublist : [itemstyle?; itemize] inline-cmd
% 
%   direct \item : [itemstyle?; inline-text] inline-cmd
% 
% end = struct
% 
% % counter
%   let-mutable counter-stack <- []
%   let display-counter () =
%     let-rec aux s lst = match lst with
%       | [] -> ` `
%       | x :: rest -> ((arabic x) ^ #` `# ^ (aux s rest))
%     in
%     `counter:` ^ (aux ` ` !counter-stack) |> display-message
% 
%   let push-counter () =
%     % match !counter-stack with
%     % | 1 :: rest -> false
%     % | _ -> let () = counter-stack <- 1 :: !counter-stack in true
%     counter-stack <- 1 :: !counter-stack
% 
%   let inc-counter n = counter-stack <- (
%     match !counter-stack with
%     | [] -> []
%     | x :: rest -> (x + n) :: rest
%   )
%   let pop-counter () = counter-stack <- (
%     match !counter-stack with
%     | [] -> []
%     | x :: rest -> rest
%   )
%   let set-counter n = counter-stack <- (
%     match !counter-stack with
%     | [] -> []
%     | x :: rest -> n :: rest
%   )
% 
%   let-inline \set-counter n = let () = set-counter n in {}
% 
% % style
%   let default-style idxlst ctx =
%     let it =
%       idxlst |> List.map (fun idx -> idx |> arabic |> embed-string)
%              |> List.fold-left (fun a b -> {#a;.#b;}) {}
%     in
%     let ib-label = read-inline ctx {[#it;]} in
%     let (w, _, _) = get-natural-metrics ib-label in
% 
%     (|
%     label = ib-label;
%     left-indent = 20pt;
%     first-line-left-indent = w +' 10pt;
%     right-indent = 0pt;
%     inner-context = (fun x -> x);
%     increment = 1;
%   |)
% 
%   let alph idxlst ctx =
%     (|
%     label = read-inline ctx {A.};
%     left-indent = 20pt;
%     first-line-left-indent = 20pt;
%     right-indent = 0pt;
%     inner-context = (fun x -> x);
%     increment = 0;
%   |)
% 
%   let no-label idxlst ctx =
%     (|
%     label = inline-nil;
%     left-indent = 20pt;
%     first-line-left-indent = 20pt;
%     right-indent = 0pt;
%     inner-context = (fun x -> x);
%     increment = 0;
%   |)
% 
% % parameters
%   let item-style = EnumitemParam.make default-style
% 
%   let deco-none _ _ _ _ = []
% 
% % command
% 
%   let-inline ctx \item ?:style it =
%     let style = style |> Option.from (EnumitemParam.get item-style) in
% 
%     let bb =
%       let () = display-counter () in
%       let record = style !counter-stack ctx in
% 
%       let is-empty ib =
%         let (w, h, d) = get-natural-metrics ib in
%         Length.(w == 0pt && h == 0pt && d == 0pt)
%       in
% 
%       let ib-label = record#label in
%       let (wid-label, _, _) = get-natural-metrics ib-label in
%       let left-indent = record#left-indent in
%       let pads = (left-indent, record#right-indent, 0pt, 0pt) in
% 
%       let bbf ctx =
% 
%         let ib-label =
%           (inline-skip (0pt -' left-indent))
%             ++ ib-label
%               ++ (inline-skip (record#first-line-left-indent -' wid-label))
%         in
% 
%         let ctx-child = record#inner-context ctx in
% 
%         let bb-par =
%           % 事前準備
%           let () = push-counter () in
%           let ib-par = read-inline ctx-child it in
%           % 後始末
%           let () = pop-counter () in
%           % カウンタを1あげる
%           let () = inc-counter record#increment in
% 
%           if (is-empty ib-par && is-empty ib-label) then
%             block-nil
%           else
%             line-break true true ctx-child (ib-label ++ ib-par ++ inline-fil)
%         in
% 
%         bb-par
%       in
% 
%       block-frame-breakable ctx pads (deco-none, deco-none, deco-none, deco-none) bbf
%     in
% 
%     inline-fil ++ embed-block-breakable ctx bb ++ omit-skip-after
% 
%   let-block ctx +itemize style inner =
%     % 事前準備
%     let () = push-counter () in
%     let old-style = EnumitemParam.get item-style in
%     let () = item-style |> EnumitemParam.set style in
% 
%     let ib = read-inline ctx inner in
% 
%     % 後始末
%     let () = item-style |> EnumitemParam.set old-style in
%     let () = pop-counter () in
% 
%     let bbf ctx =
%       line-break true true ctx (ib ++ inline-fil)
%     in
% 
%     block-frame-breakable ctx (0pt, 0pt, -10pt, 0pt) (deco-none, deco-none, deco-none, deco-none) bbf
% 
%   let-block ctx +listing ?:style (Item(_, children)) =
%     let style = style |> Option.from default-style in
%     let-rec aux (Item(it, children)) =
%       let it-children = children
%         |> List.map aux
%         |> List.fold-left (fun a b -> {#a;#b;}) {}
%       in
%       { \item{#it;#it-children;} }
%     in
%     let items = children
%       |> List.map aux
%       |> List.fold-left (fun a b -> {#a;#b;}) {}
%     in
%     read-block ctx '< +itemize(style)(items); >
% 
%   let-inline ctx \listing ?:style itemize =
%     let style = style |> Option.from default-style in
%     embed-block-breakable ctx (read-block ctx '< +listing?:(style)(itemize); >)
% 
%   let-inline ctx \sublist ?:style (Item(_, children)) =
%     let style = style |> Option.from default-style in
%     let-rec aux (Item(it, children)) =
%       let it-children = children
%         |> List.map aux
%         |> List.fold-left (fun a b -> {#a;#b;}) {}
%       in
%       { \item?:(style){#it;#it-children;} }
%     in
%     let items = children
%       |> List.map aux
%       |> List.fold-left (fun a b -> {#a;#b;}) {}
%     in
%     read-inline ctx items
% 
% 
% end
